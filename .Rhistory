import numpy as np
import trustscore # you need to have trustscore.py in the same folder as this .Rmd file to import it
import trustscore_evaluation  # you need to have trustscore_evaluation.py in the same folder as this .Rmd file to import it
import numpy as np
import matplotlib.pyplot as plt
import keras
import pandas as pd
# heads up! there might be some scary errors about "dlerror: cudart64_110.dll not found". It's just a warning and you can ignore it.
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
X_penguins = penguins_data
y_penguins = penguins_target
# prep the model
from sklearn.linear_model import LogisticRegression
# Train logistic regression on digits.
model = LogisticRegression()
model.fit(X_penguins, y_penguins.values.ravel())
y_pred = model.predict(X_penguins)
trust_model = trustscore.TrustScore()
trust_model.fit(X_penguins, y_penguins.values.ravel())
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(X_penguins, y_penguins.values.ravel())
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
print(y_penguins.values.ravel())
trust_model.fit(X_penguins, y_penguins.values.ravel())
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(X_penguins, numpy.array(y_penguins.values.ravel())
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(X_penguins, numpy.array(y_penguins.values.ravel())
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(X_penguins, np.array(y_penguins.values.ravel())
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(X_penguins, np.array(y_penguins.values.ravel()))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins.values.ravel()))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins.values.ravel()))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
py_last_error()
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins.values.ravel()))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins.values.ravel()))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
import numpy as np
import trustscore # you need to have trustscore.py in the same folder as this .Rmd file to import it
import trustscore_evaluation  # you need to have trustscore_evaluation.py in the same folder as this .Rmd file to import it
import numpy as np
import matplotlib.pyplot as plt
import keras
import pandas as pd
# heads up! there might be some scary errors about "dlerror: cudart64_110.dll not found". It's just a warning and you can ignore it.
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins.values.ravel()))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins.values.ravel()))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
X_penguins = penguins_data
y_penguins = penguins_target
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
X_penguins = penguins_data
y_penguins = penguins_target
import numpy as np
import trustscore # you need to have trustscore.py in the same folder as this .Rmd file to import it
import trustscore_evaluation  # you need to have trustscore_evaluation.py in the same folder as this .Rmd file to import it
import numpy as np
import matplotlib.pyplot as plt
import keras
import pandas as pd
# heads up! there might be some scary errors about "dlerror: cudart64_110.dll not found". It's just a warning and you can ignore it.
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
X_penguins = penguins_data
y_penguins = penguins_target
# prep the model
from sklearn.linear_model import LogisticRegression
# Train logistic regression on digits.
model = LogisticRegression()
# prep the model
from sklearn.linear_model import LogisticRegression
# Train logistic regression on digits.
model = LogisticRegression()
# implement the model
model.fit(X_penguins, y_penguins.values.ravel())
# note: I added the ravel part to make y a 1d array and solve the below error:
#" /Users/sgill/Library/r-miniconda/envs/r-reticulate/lib/python3.6/site-packages/sklearn/utils/validation.py:63: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel()."
# Create outputs on testing set.
y_pred = model.predict(X_penguins)
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), np.array(y_penguins))
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Import the default dataset from SK learn: the wine dataset and the classifying
# United States Post Office digits / handwriting.
from sklearn import datasets
wine = datasets.load_wine()
X_wine = wine.data
y_wine = wine.target
digits = datasets.load_digits()
X_digits = digits.data
y_digits = digits.target
datasets = [(X_wine, y_wine), (X_digits, y_digits)]
dataset_names = ["Wine", "Digits"]
View(digits)
View(y_digits)
View(y_digits)
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
X_penguins = penguins_data
y_penguins = np.array(penguins_target)
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
X_penguins = penguins_data
y_penguins = np.array(penguins_target.values.ravel())
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), y_penguins)
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
View(y_penguins)
View(wine)
print(wine)
print(wine$target)
print(wine[target])
print(wine.target)
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
dictionary = {}
current_index = 0
def encode(value):
if dictionary.has_key(value):
return dictionary[value]
else:
dictionary[value] = current_index
return current_index++
X_penguins = penguins_data
y_penguins = map(encode, penguins_target.values.ravel())
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
dictionary = {}
current_index = 0
def encode(value):
if dictionary.has_key(value):
return dictionary[value]
else:
dictionary[value] = current_index
return current_index++
X_penguins = penguins_data
y_penguins = map(encode, penguins_target.values.ravel())
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
dictionary = {}
current_index = 0
def encode(value):
if dictionary.has_key(value):
return dictionary[value]
else:
new_index = current_index
dictionary[value] = new_index
current_index = current_index + 1
return new_index
X_penguins = penguins_data
y_penguins = map(encode, penguins_target.values.ravel())
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
dictionary = {}
current_index = 0
def encode(value):
if dictionary.has_key(value):
return dictionary[value]
else:
new_index = current_index
dictionary[value] = new_index
current_index = current_index + 1
return new_index
X_penguins = penguins_data
y_penguins = map(encode, penguins_target.values.ravel())
print(dictionary)
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
dictionary = {}
current_index = 0
def encode(value):
if dictionary.has_key(value):
return dictionary[value]
else:
new_index = current_index
dictionary[value] = new_index
current_index = current_index + 1
return new_index
X_penguins = penguins_data
y_penguins = list(map(encode, penguins_target.values.ravel()))
print(dictionary)
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
dictionary = {}
current_index = 0
def encode(value):
if value in dictionary:
return dictionary[value]
else:
new_index = current_index
dictionary[value] = new_index
current_index = current_index + 1
return new_index
X_penguins = penguins_data
y_penguins = list(map(encode, penguins_target.values.ravel()))
print(dictionary)
# Import penguins from R into python
penguins_data = r.penguins_data
penguins_target = r.penguins_target
dictionary = {}
current_index = 0
def encode(value):
if value in dictionary:
return dictionary[value]
else:
global current_index
new_index = current_index
dictionary[value] = new_index
current_index = current_index + 1
return new_index
X_penguins = penguins_data
y_penguins = list(map(encode, penguins_target.values.ravel()))
print(dictionary)
print(y_penguins)
# prep the model
from sklearn.linear_model import LogisticRegression
# Train logistic regression on digits.
model = LogisticRegression()
# implement the model
model.fit(X_penguins, y_penguins)
# note: I added the ravel part to make y a 1d array and solve the below error:
#" /Users/sgill/Library/r-miniconda/envs/r-reticulate/lib/python3.6/site-packages/sklearn/utils/validation.py:63: DataConversionWarning: A column-vector y was passed when a 1d array was expected. Please change the shape of y to (n_samples, ), for example using ravel()."
# Create outputs on testing set.
y_pred = model.predict(X_penguins)
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), y_penguins)
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(X_penguins, y_penguins)
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(np.array(X_penguins), y_penguins)
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
# Initialize trust score.
trust_model = trustscore.TrustScore()
trust_model.fit(X_penguins, y_penguins)
# SARAH: TypeError: must be str, not int --> seems to be referring to y_penguins
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(eval = FALSE)
library(reticulate) # provides a comprehensive set of tools for interoperability between Python and R.
# configure python
reticulate::py_config() # Double check that reticulate is actually using your new conda env.
reticulate::py_install("sklearn", pip = TRUE) # force install with pip. sklearn wasn't coming up via anaconda.
reticulate::py_install("matplotlib")
reticulate::py_install("keras")
reticulate::py_install("pandas")
# setting up the Python environment and bringing in the required Python packages is important.
# It will probably take a little while so be patient and try to avoid accidentally running
# this chunk of code.
# common trouble shooting:
# if you're missing a package then try adding its name in an additonal line of py_install
# if py_install isn't working then try adding the pip = TRUE argument to try installing
# the library through pip rather than anaconda
reticulate::repl_python()
library(palmerpenguins)
library(dplyr)
# data
penguins_df <- penguins %>%
dplyr::filter(complete.cases(.)) # remove all lines with NaN so the model can be fit on the data (later)
penguins_data <- penguins_df %>%
# dplyr::select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)
dplyr::select(bill_length_mm)
# target: species
penguins_target <- penguins_df %>%
dplyr::select(species)
# make each species into a categorical variable number
reticulate::repl_python()
knitr::opts_chunk$set(echo = FALSE)
knitr::opts_chunk$set(eval = FALSE)
library(reticulate) # provides a comprehensive set of tools for interoperability between Python and R.
# configure python
reticulate::py_config() # Double check that reticulate is actually using your new conda env.
reticulate::py_install("sklearn", pip = TRUE) # force install with pip. sklearn wasn't coming up via anaconda.
reticulate::py_install("matplotlib")
reticulate::py_install("keras")
reticulate::py_install("pandas")
# setting up the Python environment and bringing in the required Python packages is important.
# It will probably take a little while so be patient and try to avoid accidentally running
# this chunk of code.
# common trouble shooting:
# if you're missing a package then try adding its name in an additonal line of py_install
# if py_install isn't working then try adding the pip = TRUE argument to try installing
# the library through pip rather than anaconda
reticulate::repl_python()
library(palmerpenguins)
library(dplyr)
# data
penguins_df <- penguins %>%
dplyr::filter(complete.cases(.)) # remove all lines with NaN so the model can be fit on the data (later)
penguins_data <- penguins_df %>%
# dplyr::select(bill_length_mm, bill_depth_mm, flipper_length_mm, body_mass_g)
dplyr::select(bill_length_mm)
# target: species
penguins_target <- penguins_df %>%
dplyr::select(species)
# make each species into a categorical variable number
reticulate::repl_python()
